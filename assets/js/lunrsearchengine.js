
var documents = [{
    "id": 0,
    "url": "https://github.com/404.html",
    "title": "404",
    "body": "404 Page does not exist!Please use the search bar at the top or visit our homepage! "
    }, {
    "id": 1,
    "url": "https://github.com/about",
    "title": "About me",
    "body": "Hello! I'm Carlos García González, also knows as Carlos Chilla or Chilla, maybe you can find me in some darkness places as Chillaso. My name it's too common so I must do tricky stuffs to get a cool username in popular sites. I'm Software Architect working at NTT Data working with microservices, DevOps and cloud technologies like Kubernetes. I spend a lot of time developing back-end APIs trying to always keep in mind Uncle Bob knowleadge, beeing always as clean as possible when writting code. I love known about software patterns, desing, achitecture and refactoring, I love reading Robert C Martin or Martin Fowler.  But not all is going to be software, there are much more! Live in nature is one of my passions, I really love trekking and camping without any material, only with my scouting skills, climb the biggest mountain to take fantastic phothos and be amazed by the incredible landscapes we have in Spain. Usually, when I go to nature, I go as scout, if you know something about scout, forget it, it's a big lie, we don't sell cookies and don't help grandmas to cross the street. We are an educational movement based on nature contact and small groups lifes, I help children and young people from 9 to 21 years to be better persons, be more critical with society they live and teach them we have to left world better than we found it.  Questions or bug reports?: Send me an email! Buy me a coffeeThank you for your support! Your donation helps me to maintain and improve The blog . Buy me a coffee Documentation"
    }, {
    "id": 2,
    "url": "https://github.com/categories",
    "title": "Categories",
    "body": ""
    }, {
    "id": 3,
    "url": "https://github.com/projects/",
    "title": "Projects",
    "body": "      Featured:                                                                                                                                                                                                           Serverless Telegram bot                              :               You don’t even think to call me Godfather. Instead, you come into my house on the day my daughter is to be married, and you. . . :                                                                                                                                                                       Carlos Chilla                                01 Apr 2020                                                                                                                    All Stories:                                                                                                   Serverless Telegram bot              :       You don’t even think to call me Godfather. Instead, you come into my house on the day my daughter is to be married, and you uh ask me to do. . . :                                                                               Carlos Chilla                01 Apr 2020                                                                                                                                  RESTful API with Spring and Kotlin              :       Hi there! Chillaso here. Today we are going to see how to build a RESTful API with Kotlin and Spring Boot. This is a project I did for a Spring. . . :                                                                               Carlos Chilla                15 Nov 2019                                          "
    }, {
    "id": 4,
    "url": "https://github.com/",
    "title": "Home",
    "body": "      Featured:                                                                                                                                                                                                               Serverless Telegram bot                              :               You don’t even think to call me Godfather. Instead, you come into my house on the day my daughter is to be married, and you. . . :                                                                                                                                                                       Carlos Chilla                                01 Apr 2020                                                                                                                                All Stories:                                                                                                         Serverless Telegram bot              :       You don’t even think to call me Godfather. Instead, you come into my house on the day my daughter is to be married, and you uh ask me to do. . . :                                                                               Carlos Chilla                01 Apr 2020                                                                                                                                                RESTful API with Spring and Kotlin              :       Hi there! Chillaso here. Today we are going to see how to build a RESTful API with Kotlin and Spring Boot. This is a project I did for a Spring. . . :                                                                               Carlos Chilla                15 Nov 2019                                                                                                                                                How to build this web              :       Hello everybody! I think the best first post I can do is how to build this website, step by step. Probably this post will change in the future in order. . . :                                                                               Carlos Chilla                12 Jun 2019                                                    "
    }, {
    "id": 5,
    "url": "https://github.com/tools",
    "title": "Tool box",
    "body": ""
    }, {
    "id": 6,
    "url": "https://github.com/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 7,
    "url": "https://github.com/sls-telegram-bot/",
    "title": "Serverless Telegram bot",
    "body": "2020/04/01 - You don’t even think to call me Godfather. Instead, you come into my house on the day my daughter is to be married, and you uh ask me to do murder, for money. Hello everybody, Chillaso is back! In this difficult days we’re living during COVID-19 I feel information necessity, but I was bored searching for graphs, news and so on… so I decided to fetch that information automatically, or as I’m going to show you, semiautomatically. Let’s see how create a Telegram bot using Serverless Framework, and some good libraries as Bent or Cheerio for NodeJS, the language we’ve decided to use for AWS Lambdas(the cloud environment). Index:  Environment installation Coding our function Serverless configuration Creating a Telegram bot Deploying and linking back-end Conclusions and resourcesEnvironment installation: Serverless philosophy let us be agnostic of cloud and language, this is a big potential because we can decide what language is better for what solution. I’ve decided to use Node. js because two reason. First one is because I want to learn more of javascript and was so bored of web javascript, I need in my life backend javascript, thanks god for Node. js. The second one is because I wanted some fast to develop, and my Golang skills are too basic right now, so the time to develop would be so long. Well, let start from a very basic installation. First at all, we’re going to install NVM, a version manager for Node, I like it because it’s very easy to install and let us change node versions very easily. As you can read in their github page, just install running the install script. 123curl -o- https://raw. githubusercontent. com/nvm-sh/nvm/v0. 35. 3/install. sh | bashexport NVM_DIR= $([ -z  ${XDG_CONFIG_HOME-}  ] &amp;&amp; printf %s  ${HOME}/. nvm  || printf %s  ${XDG_CONFIG_HOME}/nvm ) [ -s  $NVM_DIR/nvm. sh  ] &amp;&amp; \.  $NVM_DIR/nvm. sh  # This loads nvmNOTE: If you are using zsh or other terminal, check in your . zshrc if you have the export you’ve just run. Now, install a stable node version, usually your cloud provider support the latest stable version, but check it out in order to verify version you’ve to install. 1nvm install node stableAnd now it’s time to install Serverless 1npm install -g serverlessCreate the project and install serverless offline a very useful plugin to run your function in localhost. 123sls create --template aws-nodejs --path sls-telegram-botcd sls-telegram-botnpm install serverless-offline --save-devCoding our function: Our handler. js is going to be our entrypoint. We are going to see my backend logic, if you don’t mind about this point, just jump to serverless configuration section. Here I’m going to show how crawl a web with cheerio, and do http request with bent. Don’t jump the part of telegram code, how to manage message and send it. Telegram module and managing messages: Let’s see our telegram entrypoint, this is where the telegram bot event is received and processed. But not the real entrypoint, this is my telegram. js file. 12345678910111213141516171819202122232425262728293031'use strict'const bent = require('bent')const constants = require('. /constants')const utils = require('. /utils')class Telegram {  constructor(chatId, command) {    this. chatId = chatId    this. command = command  }  async sendMessage(text) {    let chat_id = this. chatId    const get = bent(200, 400);    const response = await get(constants. SEND_MESSAGE_URI, {chat_id, text, parse_mode:  HTML });    if(response. statusCode == 400)    {      let error = await utils. getBuffer(response). then(JSON. parse)      console. error(error. error_code, error. description)      text = constants. ERROR_MESSAGE      await get(constants. SEND_MESSAGE_URI, {chat_id, text, parse_mode:  HTML });    }  }}module. exports. getCommand = (event) =&gt; {  const { chat, text } = JSON. parse(event. body). message  return new Telegram(chat. id, text)}getCommand function is the first function called, parse event. body and get message object, it return chat and text objects. Chat contains the id of telegram chat, very important because we’re going to need it later to send message. Text is the text or command we’ve send it in telegram app. So if I’ve defined /increment command for my bot, text would be exactly /increment. sendMessage is an async function (sync indeed because of await) which let us send message to Telegram API, managing some possible errors. The most interesting here is 1const response = await get(constants. SEND_MESSAGE_URI, {chat_id, text, parse_mode:  HTML });parse_mode: HTML  let us send message as HTML, but take care because HTML supported is very closing. You can get more information about supported HTML here. Entrypoint function: Let’s see the real entrypoint our, handler. js 12345678910111213141516171819const getMessage = async (command) =&gt; {	switch(command)	{		case '/increment':			return await increment. getIncrement()		default:			return constants. HELP_MESSAGE	}}module. exports. covidApp = async event =&gt; {  let telegram = telegramService. getCommand(event)	await getMessage(telegram. command)	. then(message =&gt; telegram. sendMessage(message))	return {statusCode: 200}}Easy, uh? It’s very important return {statusCode:200} or whatever code when finished, if you don’t do it properly your lambda function would never finish and you would have to prepare your credit card to be fucked. At this point we have a module, telegram. js, which handle parsing telegram event and send message callback to our telegram bot. In the other hand we have our handler. js entrypoint which runs as a controller in a MVC architecture and return success code when finished. Simple as that, we’ve our backend finished Serverless configuration: Now we’re going to see required configuration in order to deploy our backend. sls create command create a serverless. yml file, THE MAGIC FILE. This is his content: 123456789101112131415161718192021222324252627282930service: covid-increment-slspackage: exclude:  - README. mdcustom: myStage: ${opt:stage, self:provider. stage} myEnvironment:  TELEGRAM_TOKEN:   prod: ${env:TELEGRAM_TOKEN}   dev: ${env:TELEGRAM_TOKEN_DEV}provider: name: aws runtime: nodejs12. x stage: dev region: eu-west-1 environment:  TELEGRAM_TOKEN: ${self:custom. myEnvironment. TELEGRAM_TOKEN. ${self:custom. myStage}}functions: covid:  handler: handler. covidApp  events:   - http:     path: covid     method: post	 cors: trueplugins: - serverless-offlineAn important point here is: 123provider: name: aws runtime: nodejs12. x Here define your cloud provider and your runtime environment. Another important point is: 12 environment:  TELEGRAM_TOKEN: ${self:custom. myEnvironment. TELEGRAM_TOKEN. ${self:custom. myStage}} Here we are setting our TELEGRAM_TOKEN variable, which let us point to our bot, we’ll see more abot this later. 12345678functions: covid:  handler: handler. covidApp  events:   - http:     path: covid     method: post	 cors: true Here we are defining a covid Api Gateway which has a handler found it in handler. covidApp function and accept a HTTP POST in http://your-api-endpoint/covid path. This isn’t a big important part of our develop, but it’s very interesting has at least 2 environments deployed, which means 2 telegram bots, which means 2 telegram tokens. So to manage this we create two different deployment configuration, prod and dev and do it possible thanks to Serverless Variables. 123456custom: myStage: ${opt:stage, self:provider. stage} myEnvironment:  TELEGRAM_TOKEN:   prod: ${env:TELEGRAM_TOKEN}   dev: ${env:TELEGRAM_TOKEN_DEV} If we want to deploy our function in dev stage we run sls deploy --stage dev Creating a Telegram bot: This step it’s very simple, just open Telegram and search for @BotFather Type /newbot and follow the instructions: Copy your telegram token and export it in your console, or export in . bashrc or . zshrc as TELEGRAM_TOKEN Now open your code and in whereever you want create a constant like this 1SEND_MESSAGE_URI: `https://api. telegram. org/bot${process. env. TELEGRAM_TOKEN}/sendMessage`,Actually, Serverless is who is going to set TELEGRAM_TOKEN depends on the stage you are deploying your function as we have seen in serverless. yml configuration. Deploying and linking back-end: It’s time to deploy, we have our bot created and our telegram token, we have our function and our serverless configuration… but… what happen with AWS? Let’s see how do a minimal configuration to deploy serverless functions, very simple. Let’s go to AWS console &gt; IAM &gt; Users.  Create an user with programmatic access and download his credentials. Then, create, if you don’t have yet, . aws folder in your home directory. Go into it and create credentials file. You’ve to write something like this: 1234[default]aws_access_key_id = ACCESS_KEYaws_secret_access_key = SECRET_ACCESS_KEYregion = eu-west-1If you are a bit confused with this, check AWS official guide to create an user and configuration and credential file setting. It’s deploy time! First you have to deploy your function with 1sls deploy --stage devThis will output something like this: As you can see Serverless create a lot of things under the hood, using services like CloudFormation, API Gateway and S3. Now copy your entrypoint URL and attach to your telegram bot, let him know where your backend is running this: 1curl --request POST --url https://api. telegram. org/bot$TELEGRAM_TOKEN_DEV/setWebhook --header 'content-type: application/json' --data '{ url :  https://your-api-endpoint/dev/covid }' you’ll get something like  1{ ok :true, result :true, description : Webhook is already set } Test your bot! Conclusions and resources: Well, thanks for reading until final. We’ve learned how to deploy a serverless function to AWS and attach to Telegram Bot. There are a lot of missing details like creating telegram commands, the backend code and an AWS deployed services. It was a very basic guide of deploying function fast and easy, from this point we can improve a lot of our code or use more AWS services as DynamoDB which let us store chat. id variable to send laterly messages to all chat who started our bot, making “subscription bots” possible. You can find my Covid project here it’s very very basic, and probably there are a lot of errors, but it’s for personal use and as a proof of concept, perhaps I’ll improve it and learn more things about it or migrate it to Golang. If you want to contribute to COVID telegram bot, don’t think it so much, do it, I’ll appreciate it so much :) I hope you enjoy and have learned something, thanks you so much for reading, See you soon, exit(0); "
    }, {
    "id": 8,
    "url": "https://github.com/kotlin-spring-restful/",
    "title": "RESTful API with Spring and Kotlin",
    "body": "2019/11/15 - Hi there! Chillaso here. Today we are going to see how to build a RESTful API with Kotlin and Spring Boot. This is a project I did for a Spring course in atSistemas I think could be useful for everyone who want to learn something about this irruptive language and its application out of Android projects. I was writting this article before, trying to explain all difference between Kotlin and Java, but I realized that it sucks cause of explaining Kotlin features/differences step by step was unuseful, the most important thing when learning Kotlin is not language features itself, is learning and understanding concepts under the hood. Hence, I’ll write a post for that concepts deep dive. So… what we’re going to learn here in this post? Well, I’ll show you good features that help us writting fast RESTful services and problems we can face up when coding Spring service with Kotlin.  All the code in this post can be found here Kotlin constructors: We’re gonna build a rent car API, so let’s start with one of my simple but favourite feature in Kotlin that allow write code like a thunder, I’m talking about Kotlin classes.   Disclaimer: Since 2017, Spring Framework 5. x and Spring Boot 2. x allow Kotlin support. This might be a problem for legacy services, but I think updating and upgrading must be a constant in our days, so if we obvious this point, I think Java community should adapt Kotlin little by little so this is why I decided use Kotlin for this project which was Java based originally. As you can see, there aren’t almost templating when creating a class. If you are familiar with Project Lombok this is very similar to @Data, but much better. Kotlin create a final class (which means you can’t inherit from it) with getters, setters, equals, toString… and that autogenerated stuffs we usually create with our IDE, but now we have this feature free with Kotlin. If you set all the attributes as val you are just setting an attribute final, and if you define a default value for it, Kotlin will create a constructor with all of your fields and one constructor for each val attribute with default falue. So, it’s mean you have a constructor with optional params, let’s see an example: Functional style: Another good stuff in Kotlin is functional programming style, which let us code cleaner. Java 8 did a nice try to get closer to functional style, but… you know, it’s fine, but sucks. Kotlin gives us different methods who can be applied to any object. Let’s see an example in a rest controller, it’s a very very basic example, but it’s fine to undertand the concept. 12override fun findById(@PathVariable( id ) id: Int): CarDTO =service. findById(id). let { mapper. mapToDto(it. get()) }This is cool, we have different methods for each semantic meaning, run, let, map, also… You could think that this is a better approach than Optionals in Java, and you’ll right in my opinion, but there is a big deal with Spring and Kotlin: Repository. If you use Spring Data, when you are implementing your DAO, you’ll have something like: 12@RepositoryInterface CarRepository : JpaRepository&lt;Car, Int&gt;And when you call your repository in your service layer, you expect something like: 1val car: Optional&lt;Car&gt; = repository. findById(id);As you can see, we’re tight to Java Optionals, and this is totally oposite to let, map, run… So, Spring it’s cool because let us implement our services with Kotlin, but is not thinked in a Kotlin way, hence, if we want to use Kotlin features we should parse our Optional to an object than can be nullable, that’s an additional step we have to implement, and Kotlin nature is be less verbose and cleaner than Java, so… Conclusions: To me, this things are the best parts of developing Spring MVC with Kotlin, in balance I think we win more than loss, even with that misunderstanding between Java and Kotlin, the last one piss off in Java’s mouth, clean code, more readability, less verbosity, better concepts… This is a very very very brief explanation about Kotlin and Spring, if you develop a real project you’ll be able to realize that Kotlin has good features like object keyword, inmutability, functional programming, better OOP… I hope you want to check it out by yourself. If you like this brief introduction to RESTful API with Spring check the project on GitHub and study the difference between Java, and try to implement your API with Kotlin, after one or two projects later, you’ll realize that Kotlin is the new black and is the better alternative to Java. In other post I’m writting now, I’ll explain Kotlin concepts that could change your mind in order to adapt Kotlin in your codebase, after that we’ll be able to see and study other cool things around Kotlin ecosystem like Arrow, coroutines, http4k and much more. Thanks for reading! "
    }, {
    "id": 9,
    "url": "https://github.com/how-to-build-this-web/",
    "title": "How to build this web",
    "body": "2019/06/12 - Hello everybody! I think the best first post I can do is how to build this website, step by step. Probably this post will change in the future in order to reflect all changes in web. Hope you enjoy and learn! Github Pages: First at all, we need to know something called GitHub Pages there is where magic occurs. Github pages host our pages and use CI/CD to mantain the page updated. We have one page per user and the free domain is like this web, chillaso. github. io. With Github Pages we have CD, so every time we push to master, a new release is created and deployed in production. Let’s start creating a new repo named as: nameyouwant. github. io Actually the name could be chillaso. github. io, but I have one created before. Notice we are choosing a public repository, only if you have pro version of github you can choose it as private Then we can check it out our repository settings, if we scroll down will see a section like this After this, we simply clone the repo, create an index. html and push it to master. After this we’ll be able to see our new incredible page! Let’s try it. 12345git clone https://github. com/Chillaso/chillaso. github. io. gitcd chillaso. github. io/echo  Hello world  &gt;&gt; index. htmlgit commit -am  Hello world git push --set-upstream origin masterSimply like this! with this little configuration we have a static website deployed on Github. With this little approach you can do whatever you think, but edit a whole site from scratch is so tedious, so let’s roll in something better, Jekyll. Jekyll Themes: Actually Github Pages uses under the hood Jekyll to render your website, and even you can choose some ugly predefined themes. But I recommend visit this website or this one and search some cool themes. These themes have predefined plugins like Disqus, sharing, Search Lunr… This has a lot of facilities, because we have an out-of-box website with cool CSS. This theme is Mediumish.  Note, take care deciding a theme becase must be github pages compatible in order to deploy in our repo. But, how can I install a custom theme on my website? Well in my case is very simple, just clone the mediumish repo and copy paste all files and folders in your project folder. Now, you can commit and start editing and customizing. I’m not going to dive in customization options because every theme is different and I guess you know something about HTML and CSS. Did you notice that you are deploying every time in master to see changes? So boring yah? Okey, let’s see how to deploy in your localhost. Jekyll works in my machine: Well, this is so fucking simple, thanks to Docker, if you know nothing about Docker, check it as soon as possible because there are several companies and technologies which use Docker in the hood, the best example is Kubernetes, but this is other post for this blog. We are going to use Docker-compose, Jekyll has an image in Docker Hub, so is simple like this: 1234567jekyll:  image: jekyll/jekyll:3. 8. 5  command: jekyll serve --force_polling  ports:    - 4000:4000  volumes:    - . :/srv/jekyllIf you know something about docker-compose, you know that we are defining a service wich image is from user jekyll and his image is jekyll in 3. 8. 5 version. We are initializing the container with jekyll serve --force_polling and binding 4000 localhost port to c 4000 container port. Then we are mounting a binding volume from . / folder to /srv/jekyll. With this approach we reuse to install Ruby on Rails, its gems, jekyll… I usually run docker-compose up -d for start the server, docker-compose restart when several changes happens, and docker-compose logs -f when need to know what is happening. Now we can visualize hot changes in localhost:4000 and start developing safety. You can create a new branch called develop and push your development code there, or you might want to use other workflow for git, like git-flow, take the best for you! Jekyll structure: Jekyll is a static site generator, you can edit your content in your favourite markup language and thanks to some tech like Liquid you can render your page easily. After building this blog I notice that Jekyll is very useful for certain pages, but other complex pages maybe you want to choose a CMS or other tools, for example Netlify or Contentful. The main reason for choosing Jekyll is that is 100% compatible with Github Pages what means you have free hosting. How Jekyll works? Well it use a specific directory structure you can see more details in their documentation, in my case I’ve the next structure: Big difference here is _pages and projects.  _pages are used to hold static root pages which haven’t templates, or don’t need to be reused.  projects this folder allow us to have a separete index. html. This index is neccesary if we want a root page like the main page. If we don’t have this files separated, we can have conflicts. Remember _pages are used to hold static content, and our projects page is going to be used as a template. In the other hand, we have a special file named, _config. yml this is a very important file to Jekyll because is used to define main configuration of our site, and let us configure plugins and other stuffs. You can check my config file here and the official documentation about default config file here. I think is a waste of time explain whole available configurations, they are very intuitive so I prefer you check documentation, and if you need know something special just try to google it, there are a lot of info for Jekyll and Github Pages. Edit content: Okey, now we have all concepts in our mind, now we need to come back to real world. How can I edit content and publish it? Well this is very easy, you only need to know a couple of things. The first one is that Jekyll use a special nomenclature to determinate what is a post, you’re going to need to allocate content under _post folder and then create a file like this: YYYY-MM-DD-name-what-you-want. md. As you can deduce, year, month and day need to be informed, and then whatever name you want which would be used to create your URL. For this post we have something like this: 2019-06-12-how-to-build-this-web. md. That’s all you need to know to editing content, that, and some of Markdown language (it’s pretty simplier). But there are some tricky stuffs that you would need to know about editing content and Jekyll concepts, headers Headers: Headers let us tell Jekyll how it has to render the page and with what info. For this post I have something like this: 12345678910---layout: posttitle:  How to build this web author: chillasocategories: [ tutorial ]tags: [jekyll, github pages, tutorial]image: assets/images/how-to-build-this-web/bricks. jpegfeatured: truehidden: false---Let’s see:  layout: Layout is what page under _layouts we are going to use as template of this content. In my case, post. html is my template, you can check its code here. Jekyll let us to inherit layouts, that’s very useful, keep in mind when develop your site.  title: Very simple, which title we are going to display in the header of the page. This is used as title in our main page too.  author: Author is a plugin I’ve installed, this indicates info about author that it’s defined in _config. yml.  categories: Is an array that can have whatever strings you want, this is useful for makes categories in your site. We can render a page like this.  tags: Like categories, but other semantic meaning.  image: I guess it isn’t necessary to explain this.  featured: This help us to difference content between featured and not featured. If we have a featured content we will display in some place but not in others and viceversa.  hidden: The same that featured, usually you’re going to have featured true and hidden true, or featured false and hidden false, that’s the right meaning, but sometimes you would like to mark a content as featured but display in your non-featured box too. As you can see, headers let us create extra information. Actually headers is a wrong name, Front Matter is the real name, and you can check Jekyll doc about this here. Conclusions: I hope you’ve learned how to build this web and know how to build yours. Now we know that Github Pages exists, and we can create a free site hosted on our Github account, customize that with themes and create and manage content thanks to Jekyll. Build this web was eight hours of work more or less. Reading post like this was probably 80% of my invested time, 20% resting was just coding and understanding how Jekylls works. Static web pages are so simple and I encourage everybody to build their own projects like this, you can learn a lot of new stuffs, enough to be manteinable and not so complex like a CMS, small projects, personal pages, simply blogs… Just code guys! Regards! "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-danger btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});